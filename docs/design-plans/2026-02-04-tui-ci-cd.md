# TUI CI/CD Pipeline Design

## Summary

This design establishes automated continuous integration and delivery pipelines for the TUI client, enabling automatic builds and releases triggered by conventional commit messages. The implementation uses GitHub Actions workflows that respond to pull requests and merges: when a PR touches TUI code, the system validates the commit format, runs tests, and builds alpha preview artifacts for testing; when changes merge to main, the system automatically calculates the next semantic version from commit history, creates a git tag, and publishes cross-platform binaries as a GitHub Release.

The approach follows patterns from the cpm project, using goreleaser for cross-platform builds (macOS, Linux, Windows across amd64/arm64 architectures), PaulHatch/semantic-version for parsing conventional commits, and build-time version injection via Go's ldflags. Version information is embedded directly into the binary and exposed via a `version` subcommand. The workflows enforce conventional commit discipline through PR title validation, ensuring consistent versioning and changelog generation. Only `feat:` and `fix:` commits trigger releases, keeping the release cadence focused on user-facing changes.

## Definition of Done

1. **PR workflow for TUI changes** creates alpha build artifacts:
   - Triggered when PR touches `tui/` files
   - Version format: `v{next_version}-alpha.{increment}+{short_sha}` (e.g., `v0.1.1-alpha.3+abc1234`)
   - Bump type inferred from PR title (conventional commit format)
   - Artifacts uploaded to GitHub Actions and linked in PR comment
   - CI checks run: fmt, vet, lint, test, build (via existing `mise run //tui:ci`)

2. **Merge workflow for TUI changes** creates tagged releases:
   - Triggered when push to `main` touches `tui/` files
   - Version calculated from conventional commits since last tag
   - Creates git tag and GitHub release with goreleaser artifacts
   - Only `feat:` and `fix:` commits trigger releases (matching cpm pattern)

3. **Conventional commit enforcement**:
   - PR titles must follow conventional commit format
   - CI check blocks merge for non-compliant PRs
   - Breaking changes detected via `feat!:`, `fix!:`, or `BREAKING CHANGE:` footer

4. **Supporting infrastructure**:
   - `.goreleaser.yml` in `tui/` (similar to cpm, without homebrew cask)
   - GitHub Actions workflows in `.github/workflows/`
   - Version package with build-time injection via ldflags
   - Version subcommand (`unquote version`) displaying version, branch, commit, date
   - Initial tag `v0.1.0` at current main tip

**Out of scope:**
- API CI/CD (future work)
- Homebrew cask distribution
- Windows ARM64 builds

## Glossary

- **Conventional Commits**: A specification for commit message format (`type(scope): description`) that enables automated semantic versioning and changelog generation. Examples: `feat(tui): add help screen`, `fix(api): correct rate limit`.
- **Semantic Versioning (SemVer)**: Version numbering scheme (MAJOR.MINOR.PATCH) where MAJOR indicates breaking changes, MINOR adds backward-compatible features, and PATCH fixes bugs.
- **Alpha build**: Pre-release build artifact created from unmerged PR code, versioned with `-alpha.N` suffix (e.g., `v0.1.1-alpha.3+abc1234`). Used for testing before merge.
- **goreleaser**: Build automation tool for Go projects that cross-compiles binaries for multiple platforms, creates archives, generates checksums, and publishes GitHub Releases.
- **ldflags**: Go linker flags that inject values into variables at build time. Used here to embed version and branch information into the compiled binary without modifying source code.
- **GitHub Actions**: GitHub's CI/CD platform that runs automated workflows triggered by repository events (pull requests, pushes, tags).
- **Path filtering**: GitHub Actions feature that triggers workflows only when specified file paths change (e.g., `paths: ['tui/**']`).
- **Snapshot mode**: goreleaser mode (`--snapshot`) that builds artifacts locally without publishing or requiring a git tag. Used for PR builds.
- **runtime/debug.BuildInfo**: Go standard library feature (since 1.18) that automatically embeds build metadata (commit SHA, timestamp, Go version) into binaries compiled with module support.
- **Breaking change**: Code change that breaks backward compatibility with previous versions. In conventional commits, indicated by `!` suffix (`feat!:`) or `BREAKING CHANGE:` footer, triggers MAJOR version bump.
- **Bump type**: Category of version increment (major, minor, patch) determined by commit types since last release.

## Architecture

Two separate GitHub Actions workflows handle PR and release scenarios:

```
┌─────────────────────────────────────────────────────────────────────┐
│                        GitHub Events                                │
└─────────────────────────────────────────────────────────────────────┘
         │                                           │
         ▼                                           ▼
┌─────────────────────────┐              ┌─────────────────────────┐
│  pull_request           │              │  push to main           │
│  (paths: tui/**)        │              │  (paths: tui/**)        │
└─────────────────────────┘              └─────────────────────────┘
         │                                           │
         ▼                                           ▼
┌─────────────────────────┐              ┌─────────────────────────┐
│  tui-pr.yml             │              │  tui-release.yml        │
│                         │              │                         │
│  1. Validate PR title   │              │  1. Check commit type   │
│  2. Run CI checks       │              │  2. Run CI checks       │
│  3. Calculate alpha     │              │  3. Calculate version   │
│     version             │              │  4. Create git tag      │
│  4. Build with          │              │  5. goreleaser release  │
│     goreleaser snapshot │              │  6. GitHub Release      │
│  5. Upload artifacts    │              │                         │
│  6. Comment on PR       │              │                         │
└─────────────────────────┘              └─────────────────────────┘
```

**Version calculation** uses [PaulHatch/semantic-version](https://github.com/PaulHatch/semantic-version) GitHub Action:
- Parses conventional commits since last tag
- Outputs version components and bump type
- Supports breaking change detection via `feat!:`, `fix!:`, and `BREAKING CHANGE:` patterns
- `change_path: tui` limits version calculation to TUI changes only

**PR title validation** uses [amannn/action-semantic-pull-request](https://github.com/amannn/action-semantic-pull-request):
- Enforces conventional commit format on PR titles
- Blocks merge if title is non-compliant

**Build artifacts** produced by [goreleaser](https://goreleaser.com/):
- Cross-platform binaries: darwin/linux/windows × amd64/arm64 (excluding windows/arm64)
- Version injected via ldflags at build time
- PR builds use `--snapshot` mode (no publish); release builds publish to GitHub Releases

**Version information** embedded in binary:
- Semantic version via ldflags (`-X ...Version={{.Version}}`)
- Branch name via ldflags (`-X ...Branch={{.Branch}}`)
- Commit SHA, timestamp, dirty flag via Go's `runtime/debug.BuildInfo` (automatic in Go 1.18+)

## Existing Patterns

This design follows patterns from [open-cli-collective/cpm](https://github.com/open-cli-collective/cpm):

**From cpm's CI workflows:**
- Path-filtered workflow triggers (`paths: ['**.go', 'go.mod', 'go.sum']`)
- Commit type gating for releases (`feat:`, `fix:` only)
- Go module caching with `actions/cache@v5`
- mise-action for tool management

**From cpm's goreleaser config:**
- Same target platforms (darwin/linux/windows × amd64/arm64, excluding windows/arm64)
- Archive format: tar.gz for unix, zip for windows
- Checksum generation
- GitHub-based changelog with commit type filtering

**Divergences from cpm:**
- No homebrew cask distribution (out of scope)
- Uses PaulHatch/semantic-version instead of version.txt + commit counting (full conventional commit parsing)
- Separate workflow files instead of auto-release triggering release workflow

## Implementation Phases

<!-- START_PHASE_1 -->
### Phase 1: Version Package

**Goal:** Create version package with build-time injection support and version subcommand

**Components:**
- `tui/internal/version/version.go` — exports `Version` and `Branch` variables (set via ldflags), `Info()` function that combines ldflags with `runtime/debug.BuildInfo` for commit/date/go version
- `tui/main.go` — add version subcommand check before Bubble Tea initialization

**Dependencies:** None

**Done when:** `go build && ./bin/unquote version` outputs version info (shows "dev" for Version until goreleaser builds)
<!-- END_PHASE_1 -->

<!-- START_PHASE_2 -->
### Phase 2: Goreleaser Configuration

**Goal:** Configure goreleaser for cross-platform builds with version injection

**Components:**
- `tui/.goreleaser.yml` — build config with ldflags for version/branch injection, archive formats, changelog filtering, release settings

**Dependencies:** Phase 1 (version package must exist for ldflags to work)

**Done when:** `cd tui && goreleaser build --snapshot --clean` produces binaries in `tui/dist/` with correct version info
<!-- END_PHASE_2 -->

<!-- START_PHASE_3 -->
### Phase 3: PR Workflow

**Goal:** Validate PR titles and build alpha artifacts on pull requests

**Components:**
- `.github/workflows/tui-pr.yml` — PR title validation job (amannn/action-semantic-pull-request), build job with version calculation (PaulHatch/semantic-version), CI checks, goreleaser snapshot build, artifact upload, PR comment

**Dependencies:** Phase 2 (goreleaser config)

**Done when:** Opening a PR that touches `tui/` triggers workflow, validates title, builds artifacts, posts comment with download link
<!-- END_PHASE_3 -->

<!-- START_PHASE_4 -->
### Phase 4: Release Workflow

**Goal:** Automatically release when feat/fix commits merge to main

**Components:**
- `.github/workflows/tui-release.yml` — commit type check (feat/fix gate), version calculation, CI checks, tag creation and push, goreleaser release

**Dependencies:** Phase 2 (goreleaser config)

**Done when:** Merging a `feat:` or `fix:` PR creates a git tag and GitHub Release with downloadable artifacts
<!-- END_PHASE_4 -->

<!-- START_PHASE_5 -->
### Phase 5: Initial Tag and Verification

**Goal:** Create initial version tag and verify full workflow

**Components:**
- Create and push `v0.1.0` tag at current main tip
- Test PR workflow end-to-end with a test branch
- Test release workflow by merging a `fix:` commit

**Dependencies:** Phases 3 and 4 (both workflows)

**Done when:** v0.1.0 tag exists, test PR shows artifacts in comment, test merge creates v0.1.1 release
<!-- END_PHASE_5 -->

## Additional Considerations

**Security:** Workflows follow principle of least privilege — PR workflow has `contents: read` and `pull-requests: write`; release workflow has `contents: write`. No secrets exposed to PR builds from forks.

**Action versions:** All actions pinned to current stable major versions (checkout@v6, cache@v5, upload-artifact@v4, etc.) per [GitHub Actions security best practices](https://www.stepsecurity.io/blog/github-actions-security-best-practices).
